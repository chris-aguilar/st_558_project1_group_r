[
  {
    "objectID": "st558_project1_group_r.html",
    "href": "st558_project1_group_r.html",
    "title": "ST 558 Project 1, Group R",
    "section": "",
    "text": "For this project, our goal is to create functions to aid in data analysis. We’ll be showcasing the following:\n\nWe’ll create a script of manual data ingestion and cleaning functions.\nOnce that works, we’ll create functions to replicate step 1.\nNext we’ll create functions to combine the prepared data.\nWe’ll create functions to plot state and county level data.\nFinally, we’ll use all the above functions on relevant subsets of the datasets.\n\n\n\nFor this project, we’ll want to read in and prepare the data for analysis. Then we’ll conduct a summary analysis using data plots.\nIn order to generate the main functions properly, we will create functions that execute data processing step that will make the code easy to maintain, debug, and reuse as necessary.\nFirst, we’ll read in and prep the data manually. Afterward, we’ll put those manual steps into a function.\nBefore we can start using tidyverse functions, we need to ensure we call them into our work library for R to use.\n\nlibrary(readr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(stringr)\n\nFor steps 1, 2 and 3 we will need to read in the .csv file, structure the data to ensure each value of interest only has one observation, and ensure we extract the year of each value from the survey code.\n\ncensus_data &lt;- read_csv(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\") |&gt; \n  select(Area_name, STCOU, ends_with(\"D\")) |&gt; # step 1\n  rename(area_name = Area_name) |&gt; \n  pivot_longer(ends_with(\"D\")) |&gt; # step 2\n  mutate(\n    measurement = substr(name, 1, 7),\n    year = paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer()) # step 3\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010187N1, EDU010187N2, EDU010188N1, EDU010188...\ndbl (20): EDU010187F, EDU010187D, EDU010188F, EDU010188D, EDU010189F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nFor step 4 we will index the data to extract the state from area_name to generate state as a separate variable. To do this we will generate a variable county_idx that will allow us to use [county_idx, ] and [-county_idx, ] to generate the county and non-county data, then classify them as “county” and “state”.\n\n# Grabbing state indices so we can split the data between county/non-county data\ncounty_idx &lt;-  grep(pattern = \", \\\\w\\\\w\", census_data$area_name)\n\n# county-level data\n# using indices for county level, and omitting indices for non-county level data\ncensus_county_lvl &lt;- census_data[county_idx, ]\ncensus_non_county_lvl &lt;- census_data[-county_idx, ]\n\n# New classes for new methods later\nclass(census_county_lvl) &lt;- c(\"county\", class(census_county_lvl))\nclass(census_non_county_lvl) &lt;- c(\"state\", class(census_non_county_lvl))\n\nIn Step 5 we use the class variables generated in Step 4 to further develop our county data frame. Using the stringr package allows us to append the 2-character state abbreviation for county level data while eliminating the need to generate a user defined function.\n\n# appending 2-char state abbreviation for county level data\ncensus_county_lvl &lt;- census_county_lvl |&gt; \n  mutate(state = stringr::str_sub(area_name, -2))\n\nIn Step 6 we will use built-in R variables to assign region information to the observations.\nThere are two versions of DC (uppercase and lowercase). The STCOUs are different for the uppercase and lowercase versions of DC so we cannot assume these are duplicate observations. Because of this we’ve standardized DC.\nAdditionally, we used upper casing state names for use in a table join to further shape the census_non_county_lvl data frame.\n\nstates_upper_case &lt;- c(toupper(state.name), \"DISTRICT OF COLUMBIA\")\n\nstates_division &lt;- c(state.division, factor(\"South Atlantic\"))\n\nstate_ref_table &lt;- data.frame(state = states_upper_case, division = states_division)\n\n# We'll join our state reference table to our census data to append divisions.\n# We do this by standardizing DC as upper case for the keys. Then, since factors can be a bit tricky, we convert to character type first. Lastly, any NAs are changed to ERROR as these don't correspond to any divisions, just \"UNITED STATES\"\n\ncensus_non_county_lvl &lt;- census_non_county_lvl |&gt; \n  mutate(area_name = toupper(area_name)) |&gt; \n  left_join(state_ref_table, by = join_by(area_name == state)) |&gt;\n  mutate(division = as.character(division),\n         division = if_else(is.na(division), \"ERROR\", division))\n\n\n\n\nNow that we’ve derived the different data framing steps, we’ll create some functions to automate the data cleaning process:\n\nRead in the census data and select Area_name, STCOU, and any column ending in “D”. We’ll also rename Area_name to area_name.\nConvert the data into long format, keeping Area_name as the reference for our enrollment values.\nA name column will create by default that contains the old column names. From these old column names, we’ll extract the survey type and the year.\nCreate two data sets, one for county-level data and one for non-county data. We’ll also add a state and county class to the relevant subsets of data.\nFor the county level data, we’ll create a variable that corresponds to the state a county belongs to.\nFor non-county level data, we’ll create a variable that corresponds to the [state’s classification of division].(https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States)\n\n\n\nWe’ll start with a function for steps 1-2. We’ll provide an optional argument that allows us to provide a name for the default value column that is created by pivot_longer.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# step 1 and 2\n\nurl &lt;- \"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\"\ndefault_var_name &lt;- \"value\"\n\nread_and_pivot &lt;- function(url, default_var_name = \"value\") {\n  \n  census_data &lt;- read_csv(url) |&gt; \n    select(Area_name, STCOU, ends_with(\"D\")) |&gt; # step 1\n    rename(area_name = Area_name) |&gt; \n    pivot_longer(ends_with(\"D\"), values_to = default_var_name) # step 2\n  \n  census_data\n}\n\n\n\n\nFrom the default name column created by pivot_longer that captures the variable names ending in “D”, we’ll extract the survey type and year, which will be reflected by the measurement and year columns created, respectively.\nWe have to be careful, however. The exploration isn’t done here, but EDU01a.csv data captures the years 1987 - 1996, where the EDU01b.csv data captures the years 1997-2006. So we need to account for the millennium we’re in. With this in mind we’ve accounted for the range of years 1930-2029 as a defensive programming measure.\n\nextract_survey_and_year &lt;- function(df) {\n  \n  res &lt;- df |&gt;\n  mutate(\n      measurement = substr(name, 1, 7),\n      # year = paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer())\n      year = ifelse(\n        substr(name, 8, 8) %in% c(\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"), paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer(),\n        ifelse(\n          substr(name, 8, 8) %in% c(\"0\", \"1\", \"2\"), paste0(\"20\", substr(name, 8, 9)) |&gt; as.integer(),\n          NA)\n        )\n  )\n  \n  res\n}\n\n\n\n\nHere we create an index (county_idx) of area_name for splitting the observations into county and non-county categories. We will use census_county_lvl for our county data, and census_non_county_lvl for our state data. We then convert these data frames into “classes” using the class() function for use in Steps 5 and 6.\n\ncounty_idx &lt;-  grep(pattern = \", \\\\w\\\\w\", census_data$area_name)\n\ncensus_county_lvl &lt;- census_data[county_idx, ]\n\ncensus_non_county_lvl &lt;- census_data[-county_idx, ]\n\nclass(census_county_lvl) &lt;- c(\"county\", class(census_county_lvl))\n\nclass(census_non_county_lvl) &lt;- c(\"state\", class(census_non_county_lvl))\n\n\n\n\nThe data from step 3 above will result in a data frame with county-level and non-county level data, each of which will require different prep methods. Here, we’ll create a function using stringr to extract the county-level state from area_name.\n\n# stringr's str_sub allows us to substring in reverse, easier than base R's substr\nextract_state_from_area &lt;- function(census_county_lvl) {\n  library(stringr) \n  \n  res &lt;- census_county_lvl |&gt; \n    mutate(state = stringr::str_sub(area_name, -2)) # grab last two characters\n  \n  res\n}\n\n\n\n\nFor non-county level data, we’ll create a function that assigns a variable that corresponds to the state’s classification of division.\nThe approach we take will make use of some built-in state data in R to join with our data frame to assign the states to a division. We explicitly cohersed the divisions to character type to ensure the mutate function worked correctly.Additionally, we assigned the value “ERROR” to any “NA” that result from an area_name not being assigned to a division.\n\nassign_state_divisions &lt;- function(census_non_county_lvl) {\n\n  states_upper_case &lt;- c(toupper(state.name), \"DISTRICT OF COLUMBIA\") # DC doesn't exist in this vector, so we add it\n  \n  states_division &lt;- c(state.division, factor(\"South Atlantic\")) # Adding DC's division level to factor vector of divisions\n  \n  state_ref_table &lt;- data.frame(state = states_upper_case, division = states_division)\n  \n  # We'll join our state reference table to our census data to append divisions.\n  # We do this by standardizing DC as upper case for the keys. Then, since factors can be a bit tricky, we convert to character type first. Lastly, any NAs are changed to ERROR as these don't correspond to any state divisions\n  \n  res &lt;- census_non_county_lvl |&gt; \n    mutate(area_name = toupper(area_name)) |&gt; \n    left_join(state_ref_table, by = join_by(area_name == state)) |&gt;\n    mutate(division = as.character(division),\n           division = if_else(is.na(division), \"ERROR\", division))\n  \n  res\n}\n\n\n\n\nWe mentioned above that the data has county-level and non-county-level data that needs to be addressed separately. The data frames we created in Step 4 will not be combined with the functions developed in Steps 5 and 6 to split the data into two data frames inside of a main object.\n\nsplit_census_data &lt;- function(census_data) {\n  \n  # use variables created in step 4\n  \n  county_idx &lt;-  grep(pattern = \", \\\\w\\\\w\", census_data$area_name)\n  \n  census_county_lvl &lt;- census_data[county_idx, ]\n\n  census_non_county_lvl &lt;- census_data[-county_idx, ]\n  \n  class(census_county_lvl) &lt;- c(\"county\", class(census_county_lvl))\n\n    class(census_non_county_lvl) &lt;- c(\"state\", class(census_non_county_lvl))\n  \n  # apply step 5 to generate county data frame\n  \n  county_res &lt;- extract_state_from_area(census_county_lvl)\n  \n  # apply step 6 to generate state data frame\n  \n  state_res &lt;- assign_state_divisions(census_non_county_lvl)\n  \n  #combine data frames into census data object \n  \n  full_res &lt;- list(county_data = county_res, state_data = state_res)\n  \n  full_res\n}\n\n\n\n\nWe’ll now create a wrapper function that combines the functions created above into one call. It’ll take as input the data’s url, and an optional argument for the enrollment column name created by pivot_longer.\n\nprepare_census_data &lt;- function(url, default_var_name = \"enrollment\") {\n  \n  res &lt;- read_and_pivot(url, default_var_name) |&gt; # step 1, 2 \n    extract_survey_and_year() |&gt; # step 3\n    split_census_data() # step 4, 5, 6\n  \n  res\n}\n\n\n\n\nNow that we have developed our data preparation function, we need to test it.\nProcessing the URLs\n\nhttps://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\nhttps://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv\n\n\ncensus_edu01a &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\", \"enrollment\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010187N1, EDU010187N2, EDU010188N1, EDU010188...\ndbl (20): EDU010187F, EDU010187D, EDU010188F, EDU010188D, EDU010189F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ncensus_edu01b &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv\", \"enrollment\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010197N1, EDU010197N2, EDU010198N1, EDU010198...\ndbl (20): EDU010197F, EDU010197D, EDU010198F, EDU010198D, EDU010199F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nBoth of these files have read in correctly, so we can move on to combining the two data frames into one using the user generated functon combine_data.\n\ncombine_data &lt;- function(list_of_dfs1, list_of_dfs2) {\n  \n  # county\n  county_res &lt;- bind_rows(list_of_dfs1$county_data, list_of_dfs2$county_data)\n  \n  # state\n  state_res &lt;- bind_rows(list_of_dfs1$state_data, list_of_dfs2$state_data)\n  \n  res &lt;- list(county_data = county_res, state_data = state_res)\n  \n  res\n}\n\nWe now call our combine_data function to save the results of the prepared EDU01a and EDU01b data sets into a two-element list of dataframes, where each element of the list corresponds to combined county-level and state-level data.\n\ncensus_data &lt;- combine_data(census_edu01a, census_edu01b)\n\ncensus_data\n\n$county_data\n# A tibble: 62,900 × 7\n   area_name   STCOU name       enrollment measurement  year state\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;\n 1 Autauga, AL 01001 EDU010187D       6829 EDU0101      1987 AL   \n 2 Autauga, AL 01001 EDU010188D       6900 EDU0101      1988 AL   \n 3 Autauga, AL 01001 EDU010189D       6920 EDU0101      1989 AL   \n 4 Autauga, AL 01001 EDU010190D       6847 EDU0101      1990 AL   \n 5 Autauga, AL 01001 EDU010191D       7008 EDU0101      1991 AL   \n 6 Autauga, AL 01001 EDU010192D       7137 EDU0101      1992 AL   \n 7 Autauga, AL 01001 EDU010193D       7152 EDU0101      1993 AL   \n 8 Autauga, AL 01001 EDU010194D       7381 EDU0101      1994 AL   \n 9 Autauga, AL 01001 EDU010195D       7568 EDU0101      1995 AL   \n10 Autauga, AL 01001 EDU010196D       7834 EDU0101      1996 AL   \n# ℹ 62,890 more rows\n\n$state_data\n# A tibble: 1,060 × 7\n   area_name     STCOU name       enrollment measurement  year division\n   &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;   \n 1 UNITED STATES 00000 EDU010187D   40024299 EDU0101      1987 ERROR   \n 2 UNITED STATES 00000 EDU010188D   39967624 EDU0101      1988 ERROR   \n 3 UNITED STATES 00000 EDU010189D   40317775 EDU0101      1989 ERROR   \n 4 UNITED STATES 00000 EDU010190D   40737600 EDU0101      1990 ERROR   \n 5 UNITED STATES 00000 EDU010191D   41385442 EDU0101      1991 ERROR   \n 6 UNITED STATES 00000 EDU010192D   42088151 EDU0101      1992 ERROR   \n 7 UNITED STATES 00000 EDU010193D   42724710 EDU0101      1993 ERROR   \n 8 UNITED STATES 00000 EDU010194D   43369917 EDU0101      1994 ERROR   \n 9 UNITED STATES 00000 EDU010195D   43993459 EDU0101      1995 ERROR   \n10 UNITED STATES 00000 EDU010196D   44715737 EDU0101      1996 ERROR   \n# ℹ 1,050 more rows\n\n\nWe are now ready to analyze this data.\n\n\n\n\nFor the State class plot we’ve developed a function that maps the mean value of the variable of interest, in this case enrollment, across the years for each Division. There are twenty “Error” values for Division that have been removed as part of generating the subset prior to plotting the data.\n\n# specify data frame, default variable name, \nplot.state &lt;- function(df, var_name = \"enrollment\"){\n  library(ggplot2)\n  \n# create subset data for plotting\nstate_variable_plot &lt;- df$state_data |&gt;\n\n# remove the error values\n    filter(division != \"ERROR\") |&gt;  \n\n# subset the data to the variables of interest\n    group_by(division, year) |&gt; \n  #create the mean statistic for plotting\n    summarize(\"mean_value\" = mean(get(var_name)))\n\n# generate the plot of year vs mean\n  g_state &lt;- ggplot(state_variable_plot, aes(year, mean_value, color=division)) \n\n# plot the division values\n  g_state + \n    geom_line() +\n    labs(title = paste(\"Average yearly\", var_name, \"by state division\")) +\n    xlab(\"Year\") +\n    ylab(paste(\"Average\", var_name))\n\n}\n\n# Calling on a dataframe of class \"state\" with a default variable-of-interest called \"enrollment\"\nplot.state(census_data)\n\n`summarise()` has grouped output by 'division'. You can override using the\n`.groups` argument.\n\n\n\n\n\n\n\n\n\n\n\n\nNext we created a similar plotting function with more flexibility. The county plotting function allows the user to specify a state of interest and determine how many of the top or bottom counties in the state they want to observe the average enrollment for.\n\n# specify state, top/bottom, and number of results displayed in the function\nplot.county &lt;- function(df, var_name = \"enrollment\", state_val = \"NC\", group = \"top\", row_display = 5) {\n  library(ggplot2)\n  library(stringr)\n  \n# extract the county df from the census_data object\n  county_variable_subset &lt;-  df$county_data |&gt;\n\n# filter the data to show only the state specified in the function string\n    filter(state == state_val) |&gt;\n    \n# find the overall mean of the statistic for each area name\n    group_by(area_name) |&gt; \n    summarize(\"mean_value\" = mean(get(var_name))) \n  \n# Sort the data to display the enrollment means from largest to smallest when \"top\" is chosen, or from smallets to largest when \"bottom\" is chosen. \n\nif(group == \"top\") {\n  sorted_data &lt;- county_variable_subset |&gt; arrange(desc(mean_value))\n} else if(group == \"bottom\") {\n  sorted_data &lt;- county_variable_subset |&gt; arrange(mean_value)\n} else {\n  stop(\"group must be in one of c('top', 'bottom')\")\n}\n  \n# obtain the top or bottom x number of area_names where the number is given by the user or default and filter the data to only include the top or bottom area names for graphing\n  \n  Display_num_subset &lt;- head(sorted_data, row_display)\n\n  # obtaining data corresponding to the top/bottom counties of interest\n  \n  counties_of_interest &lt;- df$county_data |&gt; semi_join(Display_num_subset, by = join_by(area_name))\n  \n  counties_of_interest |&gt; \n    ggplot(aes(x = year, y = get(var_name), color = area_name)) + \n    geom_line() +\n    xlab(\"Year\") +\n    ylab(str_to_title(str_replace(get(\"var_name\"), pattern = \"_\", replacement = \" \"))) +\n    labs(title = paste(str_to_title(paste(var_name, \"by county\")), \"in\", state_val), \n         subtitle = str_to_sentence(paste(group, row_display, \"counties\")))\n\n}\n\n# Calling on a dataframe of class \"county\" with a default values that produce the top 5 enrollment counties in NC. \nplot.county(census_data)\n\n\n\n\n\n\n\n\nWe can now utilize the above methods plot.state and plot.county to create time series plots for our numeric values of interest, and plots of the average value of interest by county."
  },
  {
    "objectID": "st558_project1_group_r.html#manual-read-in",
    "href": "st558_project1_group_r.html#manual-read-in",
    "title": "ST 558 Project 1, Group R",
    "section": "",
    "text": "For this project, we’ll want to read in and prepare the data for analysis. Then we’ll conduct a summary analysis using data plots.\nIn order to generate the main functions properly, we will create functions that execute data processing step that will make the code easy to maintain, debug, and reuse as necessary.\nFirst, we’ll read in and prep the data manually. Afterward, we’ll put those manual steps into a function.\nBefore we can start using tidyverse functions, we need to ensure we call them into our work library for R to use.\n\nlibrary(readr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(stringr)\n\nFor steps 1, 2 and 3 we will need to read in the .csv file, structure the data to ensure each value of interest only has one observation, and ensure we extract the year of each value from the survey code.\n\ncensus_data &lt;- read_csv(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\") |&gt; \n  select(Area_name, STCOU, ends_with(\"D\")) |&gt; # step 1\n  rename(area_name = Area_name) |&gt; \n  pivot_longer(ends_with(\"D\")) |&gt; # step 2\n  mutate(\n    measurement = substr(name, 1, 7),\n    year = paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer()) # step 3\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010187N1, EDU010187N2, EDU010188N1, EDU010188...\ndbl (20): EDU010187F, EDU010187D, EDU010188F, EDU010188D, EDU010189F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nFor step 4 we will index the data to extract the state from area_name to generate state as a separate variable. To do this we will generate a variable county_idx that will allow us to use [county_idx, ] and [-county_idx, ] to generate the county and non-county data, then classify them as “county” and “state”.\n\n# Grabbing state indices so we can split the data between county/non-county data\ncounty_idx &lt;-  grep(pattern = \", \\\\w\\\\w\", census_data$area_name)\n\n# county-level data\n# using indices for county level, and omitting indices for non-county level data\ncensus_county_lvl &lt;- census_data[county_idx, ]\ncensus_non_county_lvl &lt;- census_data[-county_idx, ]\n\n# New classes for new methods later\nclass(census_county_lvl) &lt;- c(\"county\", class(census_county_lvl))\nclass(census_non_county_lvl) &lt;- c(\"state\", class(census_non_county_lvl))\n\nIn Step 5 we use the class variables generated in Step 4 to further develop our county data frame. Using the stringr package allows us to append the 2-character state abbreviation for county level data while eliminating the need to generate a user defined function.\n\n# appending 2-char state abbreviation for county level data\ncensus_county_lvl &lt;- census_county_lvl |&gt; \n  mutate(state = stringr::str_sub(area_name, -2))\n\nIn Step 6 we will use built-in R variables to assign region information to the observations.\nThere are two versions of DC (uppercase and lowercase). The STCOUs are different for the uppercase and lowercase versions of DC so we cannot assume these are duplicate observations. Because of this we’ve standardized DC.\nAdditionally, we used upper casing state names for use in a table join to further shape the census_non_county_lvl data frame.\n\nstates_upper_case &lt;- c(toupper(state.name), \"DISTRICT OF COLUMBIA\")\n\nstates_division &lt;- c(state.division, factor(\"South Atlantic\"))\n\nstate_ref_table &lt;- data.frame(state = states_upper_case, division = states_division)\n\n# We'll join our state reference table to our census data to append divisions.\n# We do this by standardizing DC as upper case for the keys. Then, since factors can be a bit tricky, we convert to character type first. Lastly, any NAs are changed to ERROR as these don't correspond to any divisions, just \"UNITED STATES\"\n\ncensus_non_county_lvl &lt;- census_non_county_lvl |&gt; \n  mutate(area_name = toupper(area_name)) |&gt; \n  left_join(state_ref_table, by = join_by(area_name == state)) |&gt;\n  mutate(division = as.character(division),\n         division = if_else(is.na(division), \"ERROR\", division))"
  },
  {
    "objectID": "st558_project1_group_r.html#creating-data-pre-processing-functions",
    "href": "st558_project1_group_r.html#creating-data-pre-processing-functions",
    "title": "ST 558 Project 1, Group R",
    "section": "",
    "text": "Now that we’ve derived the different data framing steps, we’ll create some functions to automate the data cleaning process:\n\nRead in the census data and select Area_name, STCOU, and any column ending in “D”. We’ll also rename Area_name to area_name.\nConvert the data into long format, keeping Area_name as the reference for our enrollment values.\nA name column will create by default that contains the old column names. From these old column names, we’ll extract the survey type and the year.\nCreate two data sets, one for county-level data and one for non-county data. We’ll also add a state and county class to the relevant subsets of data.\nFor the county level data, we’ll create a variable that corresponds to the state a county belongs to.\nFor non-county level data, we’ll create a variable that corresponds to the [state’s classification of division].(https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States)\n\n\n\nWe’ll start with a function for steps 1-2. We’ll provide an optional argument that allows us to provide a name for the default value column that is created by pivot_longer.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# step 1 and 2\n\nurl &lt;- \"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\"\ndefault_var_name &lt;- \"value\"\n\nread_and_pivot &lt;- function(url, default_var_name = \"value\") {\n  \n  census_data &lt;- read_csv(url) |&gt; \n    select(Area_name, STCOU, ends_with(\"D\")) |&gt; # step 1\n    rename(area_name = Area_name) |&gt; \n    pivot_longer(ends_with(\"D\"), values_to = default_var_name) # step 2\n  \n  census_data\n}\n\n\n\n\nFrom the default name column created by pivot_longer that captures the variable names ending in “D”, we’ll extract the survey type and year, which will be reflected by the measurement and year columns created, respectively.\nWe have to be careful, however. The exploration isn’t done here, but EDU01a.csv data captures the years 1987 - 1996, where the EDU01b.csv data captures the years 1997-2006. So we need to account for the millennium we’re in. With this in mind we’ve accounted for the range of years 1930-2029 as a defensive programming measure.\n\nextract_survey_and_year &lt;- function(df) {\n  \n  res &lt;- df |&gt;\n  mutate(\n      measurement = substr(name, 1, 7),\n      # year = paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer())\n      year = ifelse(\n        substr(name, 8, 8) %in% c(\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"), paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer(),\n        ifelse(\n          substr(name, 8, 8) %in% c(\"0\", \"1\", \"2\"), paste0(\"20\", substr(name, 8, 9)) |&gt; as.integer(),\n          NA)\n        )\n  )\n  \n  res\n}\n\n\n\n\nHere we create an index (county_idx) of area_name for splitting the observations into county and non-county categories. We will use census_county_lvl for our county data, and census_non_county_lvl for our state data. We then convert these data frames into “classes” using the class() function for use in Steps 5 and 6.\n\ncounty_idx &lt;-  grep(pattern = \", \\\\w\\\\w\", census_data$area_name)\n\ncensus_county_lvl &lt;- census_data[county_idx, ]\n\ncensus_non_county_lvl &lt;- census_data[-county_idx, ]\n\nclass(census_county_lvl) &lt;- c(\"county\", class(census_county_lvl))\n\nclass(census_non_county_lvl) &lt;- c(\"state\", class(census_non_county_lvl))\n\n\n\n\nThe data from step 3 above will result in a data frame with county-level and non-county level data, each of which will require different prep methods. Here, we’ll create a function using stringr to extract the county-level state from area_name.\n\n# stringr's str_sub allows us to substring in reverse, easier than base R's substr\nextract_state_from_area &lt;- function(census_county_lvl) {\n  library(stringr) \n  \n  res &lt;- census_county_lvl |&gt; \n    mutate(state = stringr::str_sub(area_name, -2)) # grab last two characters\n  \n  res\n}\n\n\n\n\nFor non-county level data, we’ll create a function that assigns a variable that corresponds to the state’s classification of division.\nThe approach we take will make use of some built-in state data in R to join with our data frame to assign the states to a division. We explicitly cohersed the divisions to character type to ensure the mutate function worked correctly.Additionally, we assigned the value “ERROR” to any “NA” that result from an area_name not being assigned to a division.\n\nassign_state_divisions &lt;- function(census_non_county_lvl) {\n\n  states_upper_case &lt;- c(toupper(state.name), \"DISTRICT OF COLUMBIA\") # DC doesn't exist in this vector, so we add it\n  \n  states_division &lt;- c(state.division, factor(\"South Atlantic\")) # Adding DC's division level to factor vector of divisions\n  \n  state_ref_table &lt;- data.frame(state = states_upper_case, division = states_division)\n  \n  # We'll join our state reference table to our census data to append divisions.\n  # We do this by standardizing DC as upper case for the keys. Then, since factors can be a bit tricky, we convert to character type first. Lastly, any NAs are changed to ERROR as these don't correspond to any state divisions\n  \n  res &lt;- census_non_county_lvl |&gt; \n    mutate(area_name = toupper(area_name)) |&gt; \n    left_join(state_ref_table, by = join_by(area_name == state)) |&gt;\n    mutate(division = as.character(division),\n           division = if_else(is.na(division), \"ERROR\", division))\n  \n  res\n}\n\n\n\n\nWe mentioned above that the data has county-level and non-county-level data that needs to be addressed separately. The data frames we created in Step 4 will not be combined with the functions developed in Steps 5 and 6 to split the data into two data frames inside of a main object.\n\nsplit_census_data &lt;- function(census_data) {\n  \n  # use variables created in step 4\n  \n  county_idx &lt;-  grep(pattern = \", \\\\w\\\\w\", census_data$area_name)\n  \n  census_county_lvl &lt;- census_data[county_idx, ]\n\n  census_non_county_lvl &lt;- census_data[-county_idx, ]\n  \n  class(census_county_lvl) &lt;- c(\"county\", class(census_county_lvl))\n\n    class(census_non_county_lvl) &lt;- c(\"state\", class(census_non_county_lvl))\n  \n  # apply step 5 to generate county data frame\n  \n  county_res &lt;- extract_state_from_area(census_county_lvl)\n  \n  # apply step 6 to generate state data frame\n  \n  state_res &lt;- assign_state_divisions(census_non_county_lvl)\n  \n  #combine data frames into census data object \n  \n  full_res &lt;- list(county_data = county_res, state_data = state_res)\n  \n  full_res\n}\n\n\n\n\nWe’ll now create a wrapper function that combines the functions created above into one call. It’ll take as input the data’s url, and an optional argument for the enrollment column name created by pivot_longer.\n\nprepare_census_data &lt;- function(url, default_var_name = \"enrollment\") {\n  \n  res &lt;- read_and_pivot(url, default_var_name) |&gt; # step 1, 2 \n    extract_survey_and_year() |&gt; # step 3\n    split_census_data() # step 4, 5, 6\n  \n  res\n}\n\n\n\n\nNow that we have developed our data preparation function, we need to test it.\nProcessing the URLs\n\nhttps://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\nhttps://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv\n\n\ncensus_edu01a &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\", \"enrollment\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010187N1, EDU010187N2, EDU010188N1, EDU010188...\ndbl (20): EDU010187F, EDU010187D, EDU010188F, EDU010188D, EDU010189F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ncensus_edu01b &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv\", \"enrollment\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010197N1, EDU010197N2, EDU010198N1, EDU010198...\ndbl (20): EDU010197F, EDU010197D, EDU010198F, EDU010198D, EDU010199F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nBoth of these files have read in correctly, so we can move on to combining the two data frames into one using the user generated functon combine_data.\n\ncombine_data &lt;- function(list_of_dfs1, list_of_dfs2) {\n  \n  # county\n  county_res &lt;- bind_rows(list_of_dfs1$county_data, list_of_dfs2$county_data)\n  \n  # state\n  state_res &lt;- bind_rows(list_of_dfs1$state_data, list_of_dfs2$state_data)\n  \n  res &lt;- list(county_data = county_res, state_data = state_res)\n  \n  res\n}\n\nWe now call our combine_data function to save the results of the prepared EDU01a and EDU01b data sets into a two-element list of dataframes, where each element of the list corresponds to combined county-level and state-level data.\n\ncensus_data &lt;- combine_data(census_edu01a, census_edu01b)\n\ncensus_data\n\n$county_data\n# A tibble: 62,900 × 7\n   area_name   STCOU name       enrollment measurement  year state\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;\n 1 Autauga, AL 01001 EDU010187D       6829 EDU0101      1987 AL   \n 2 Autauga, AL 01001 EDU010188D       6900 EDU0101      1988 AL   \n 3 Autauga, AL 01001 EDU010189D       6920 EDU0101      1989 AL   \n 4 Autauga, AL 01001 EDU010190D       6847 EDU0101      1990 AL   \n 5 Autauga, AL 01001 EDU010191D       7008 EDU0101      1991 AL   \n 6 Autauga, AL 01001 EDU010192D       7137 EDU0101      1992 AL   \n 7 Autauga, AL 01001 EDU010193D       7152 EDU0101      1993 AL   \n 8 Autauga, AL 01001 EDU010194D       7381 EDU0101      1994 AL   \n 9 Autauga, AL 01001 EDU010195D       7568 EDU0101      1995 AL   \n10 Autauga, AL 01001 EDU010196D       7834 EDU0101      1996 AL   \n# ℹ 62,890 more rows\n\n$state_data\n# A tibble: 1,060 × 7\n   area_name     STCOU name       enrollment measurement  year division\n   &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;   \n 1 UNITED STATES 00000 EDU010187D   40024299 EDU0101      1987 ERROR   \n 2 UNITED STATES 00000 EDU010188D   39967624 EDU0101      1988 ERROR   \n 3 UNITED STATES 00000 EDU010189D   40317775 EDU0101      1989 ERROR   \n 4 UNITED STATES 00000 EDU010190D   40737600 EDU0101      1990 ERROR   \n 5 UNITED STATES 00000 EDU010191D   41385442 EDU0101      1991 ERROR   \n 6 UNITED STATES 00000 EDU010192D   42088151 EDU0101      1992 ERROR   \n 7 UNITED STATES 00000 EDU010193D   42724710 EDU0101      1993 ERROR   \n 8 UNITED STATES 00000 EDU010194D   43369917 EDU0101      1994 ERROR   \n 9 UNITED STATES 00000 EDU010195D   43993459 EDU0101      1995 ERROR   \n10 UNITED STATES 00000 EDU010196D   44715737 EDU0101      1996 ERROR   \n# ℹ 1,050 more rows\n\n\nWe are now ready to analyze this data."
  },
  {
    "objectID": "st558_project1_group_r.html#class-state-plotting-function",
    "href": "st558_project1_group_r.html#class-state-plotting-function",
    "title": "ST 558 Project 1, Group R",
    "section": "",
    "text": "For the State class plot we’ve developed a function that maps the mean value of the variable of interest, in this case enrollment, across the years for each Division. There are twenty “Error” values for Division that have been removed as part of generating the subset prior to plotting the data.\n\n# specify data frame, default variable name, \nplot.state &lt;- function(df, var_name = \"enrollment\"){\n  library(ggplot2)\n  \n# create subset data for plotting\nstate_variable_plot &lt;- df$state_data |&gt;\n\n# remove the error values\n    filter(division != \"ERROR\") |&gt;  \n\n# subset the data to the variables of interest\n    group_by(division, year) |&gt; \n  #create the mean statistic for plotting\n    summarize(\"mean_value\" = mean(get(var_name)))\n\n# generate the plot of year vs mean\n  g_state &lt;- ggplot(state_variable_plot, aes(year, mean_value, color=division)) \n\n# plot the division values\n  g_state + \n    geom_line() +\n    labs(title = paste(\"Average yearly\", var_name, \"by state division\")) +\n    xlab(\"Year\") +\n    ylab(paste(\"Average\", var_name))\n\n}\n\n# Calling on a dataframe of class \"state\" with a default variable-of-interest called \"enrollment\"\nplot.state(census_data)\n\n`summarise()` has grouped output by 'division'. You can override using the\n`.groups` argument."
  },
  {
    "objectID": "st558_project1_group_r.html#class-county-plotting-function",
    "href": "st558_project1_group_r.html#class-county-plotting-function",
    "title": "ST 558 Project 1, Group R",
    "section": "",
    "text": "Next we created a similar plotting function with more flexibility. The county plotting function allows the user to specify a state of interest and determine how many of the top or bottom counties in the state they want to observe the average enrollment for.\n\n# specify state, top/bottom, and number of results displayed in the function\nplot.county &lt;- function(df, var_name = \"enrollment\", state_val = \"NC\", group = \"top\", row_display = 5) {\n  library(ggplot2)\n  library(stringr)\n  \n# extract the county df from the census_data object\n  county_variable_subset &lt;-  df$county_data |&gt;\n\n# filter the data to show only the state specified in the function string\n    filter(state == state_val) |&gt;\n    \n# find the overall mean of the statistic for each area name\n    group_by(area_name) |&gt; \n    summarize(\"mean_value\" = mean(get(var_name))) \n  \n# Sort the data to display the enrollment means from largest to smallest when \"top\" is chosen, or from smallets to largest when \"bottom\" is chosen. \n\nif(group == \"top\") {\n  sorted_data &lt;- county_variable_subset |&gt; arrange(desc(mean_value))\n} else if(group == \"bottom\") {\n  sorted_data &lt;- county_variable_subset |&gt; arrange(mean_value)\n} else {\n  stop(\"group must be in one of c('top', 'bottom')\")\n}\n  \n# obtain the top or bottom x number of area_names where the number is given by the user or default and filter the data to only include the top or bottom area names for graphing\n  \n  Display_num_subset &lt;- head(sorted_data, row_display)\n\n  # obtaining data corresponding to the top/bottom counties of interest\n  \n  counties_of_interest &lt;- df$county_data |&gt; semi_join(Display_num_subset, by = join_by(area_name))\n  \n  counties_of_interest |&gt; \n    ggplot(aes(x = year, y = get(var_name), color = area_name)) + \n    geom_line() +\n    xlab(\"Year\") +\n    ylab(str_to_title(str_replace(get(\"var_name\"), pattern = \"_\", replacement = \" \"))) +\n    labs(title = paste(str_to_title(paste(var_name, \"by county\")), \"in\", state_val), \n         subtitle = str_to_sentence(paste(group, row_display, \"counties\")))\n\n}\n\n# Calling on a dataframe of class \"county\" with a default values that produce the top 5 enrollment counties in NC. \nplot.county(census_data)\n\n\n\n\n\n\n\n\nWe can now utilize the above methods plot.state and plot.county to create time series plots for our numeric values of interest, and plots of the average value of interest by county."
  },
  {
    "objectID": "st558_project1_group_r.html#data-processing",
    "href": "st558_project1_group_r.html#data-processing",
    "title": "ST 558 Project 1, Group R",
    "section": "Data processing",
    "text": "Data processing\n\nprepare_census_data &lt;- function(url, default_var_name = \"enrollment\") {\n\n# create libraries for package use\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\n\n\n# # step 1 and 2 and 3. Read URL into census_data df, then mutatae to create single observations for each survey code ending with \"D\".\n\n\nread_and_pivot &lt;- function(url, default_var_name = \"value\") {\n  \n  census_data &lt;- read_csv(url) |&gt; \n    select(Area_name, STCOU, ends_with(\"D\")) |&gt; # step 1\n    rename(area_name = Area_name) |&gt; \n    pivot_longer(ends_with(\"D\"), values_to = default_var_name) # step 2\n  \n  census_data\n}\n\n\n# extract the year from the survey code\n\n\nextract_survey_and_year &lt;- function(df) {\n  \n  res &lt;- df |&gt;\n  mutate(\n      measurement = substr(name, 1, 7),\n      # year = paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer())\n      year = ifelse(\n        substr(name, 8, 8) %in% c(\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"), paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer(),\n        ifelse(\n          substr(name, 8, 8) %in% c(\"0\", \"1\", \"2\"), paste0(\"20\", substr(name, 8, 9)) |&gt; as.integer(),\n          NA)\n        )\n  )\n  \n  res\n}\n\n\n# separate the state data from the area data\n\n\nextract_state_from_area &lt;- function(census_county_lvl) {\n  res &lt;- census_county_lvl |&gt; \n    mutate(state = stringr::str_sub(area_name, -2)) # grab last two characters\n  \n  res\n}\n\n\n# assign the state divisions to the non-county data frame\n\nassign_state_divisions &lt;- function(census_non_county_lvl) {\n  # Making reference table\n  # Upper casing state names for table join later\n  states_upper_case &lt;- c(toupper(state.name), \"DISTRICT OF COLUMBIA\") # DC doesn't exist in this vector, so we add it\n  \n  states_division &lt;- c(state.division, factor(\"South Atlantic\")) # Adding DC's division level to factor vector of divisions\n  \n  state_ref_table &lt;- data.frame(state = states_upper_case, division = states_division)\n  \n  # We'll join our state reference table to our census data to append divisions.\n  # We do this by standardizing DC as upper case for the keys. Then, since factors can be a bit tricky, we convert to character type first. Lastly, any NAs are changed to ERROR as these don't correspond to any state divisions\n  \n  res &lt;- census_non_county_lvl |&gt; \n    mutate(area_name = toupper(area_name)) |&gt; \n    left_join(state_ref_table, by = join_by(area_name == state)) |&gt;\n    mutate(division = as.character(division),\n           division = if_else(is.na(division), \"ERROR\", division))\n  \n  res\n}\n\n\n# split the census data into state and county data frames\n\n\nsplit_census_data &lt;- function(census_data) {\n  \n  # step 4\n  \n  # Grabbing state indices so we can split the data between county/non-county data\n  # This is because county-level data follows the pattern \"County, DD\"\n  # DD is the state abbreviation.\n  county_idx &lt;-  grep(pattern = \", \\\\w\\\\w\", census_data$area_name)\n  \n  # using indices for county level, and omitting indices for non-county level data\n  census_county_lvl &lt;- census_data[county_idx, ]\n  census_non_county_lvl &lt;- census_data[-county_idx, ]\n  \n  # New classes for new methods later\n  class(census_county_lvl) &lt;- c(\"county\", class(census_county_lvl))\n  class(census_non_county_lvl) &lt;- c(\"state\", class(census_non_county_lvl))\n  \n  # step 5\n  \n  # applying step 5 for county level data\n  county_res &lt;- extract_state_from_area(census_county_lvl)\n  \n  # step 6\n  \n  # applying step 6 for non-county level data\n  state_res &lt;- assign_state_divisions(census_non_county_lvl)\n  \n  full_res &lt;- list(county_data = county_res, state_data = state_res)\n  \n  full_res\n}\n\n  res &lt;- read_and_pivot(url, default_var_name) |&gt; # step 1, 2 \n    extract_survey_and_year() |&gt; # step 3\n    split_census_data() # step 4, 5, 6\n  \n  res\n\n}\n\nNext we will run our combine_data code that will allow us to use the function to combine the separate URL data sets into one object with separate data frames for state and county data.\n\ncombine_data &lt;- function(list_of_dfs1, list_of_dfs2) {\n  \n  # county\n  county_res &lt;- bind_rows(list_of_dfs1$county_data, list_of_dfs2$county_data)\n  \n  # state\n  state_res &lt;- bind_rows(list_of_dfs1$state_data, list_of_dfs2$state_data)\n  \n  res &lt;- list(county_data = county_res, state_data = state_res)\n  \n  res\n}\n\nNext, we will run each of the the census raw data URLs through our prepare_census_data function to generate data frames for combining into the census_data object we will be using for summary analysis.\n\n# Reading in and prepping the two EDU01 census .csv files given\n\ncensus_edu01a &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\", \"enrollment\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010187N1, EDU010187N2, EDU010188N1, EDU010188...\ndbl (20): EDU010187F, EDU010187D, EDU010188F, EDU010188D, EDU010189F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ncensus_edu01b &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv\", \"enrollment\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010197N1, EDU010197N2, EDU010198N1, EDU010198...\ndbl (20): EDU010197F, EDU010197D, EDU010198F, EDU010198D, EDU010199F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "st558_project1_group_r.html#data-combining",
    "href": "st558_project1_group_r.html#data-combining",
    "title": "ST 558 Project 1, Group R",
    "section": "Data combining",
    "text": "Data combining\nNow that we have converted the raw data into usable tibbles we can process them through our combine_data function to generate the census_data object.\n\ncensus_data &lt;- combine_data(census_edu01a, census_edu01b)\n\ncensus_data\n\n$county_data\n# A tibble: 62,900 × 7\n   area_name   STCOU name       enrollment measurement  year state\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;\n 1 Autauga, AL 01001 EDU010187D       6829 EDU0101      1987 AL   \n 2 Autauga, AL 01001 EDU010188D       6900 EDU0101      1988 AL   \n 3 Autauga, AL 01001 EDU010189D       6920 EDU0101      1989 AL   \n 4 Autauga, AL 01001 EDU010190D       6847 EDU0101      1990 AL   \n 5 Autauga, AL 01001 EDU010191D       7008 EDU0101      1991 AL   \n 6 Autauga, AL 01001 EDU010192D       7137 EDU0101      1992 AL   \n 7 Autauga, AL 01001 EDU010193D       7152 EDU0101      1993 AL   \n 8 Autauga, AL 01001 EDU010194D       7381 EDU0101      1994 AL   \n 9 Autauga, AL 01001 EDU010195D       7568 EDU0101      1995 AL   \n10 Autauga, AL 01001 EDU010196D       7834 EDU0101      1996 AL   \n# ℹ 62,890 more rows\n\n$state_data\n# A tibble: 1,060 × 7\n   area_name     STCOU name       enrollment measurement  year division\n   &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;   \n 1 UNITED STATES 00000 EDU010187D   40024299 EDU0101      1987 ERROR   \n 2 UNITED STATES 00000 EDU010188D   39967624 EDU0101      1988 ERROR   \n 3 UNITED STATES 00000 EDU010189D   40317775 EDU0101      1989 ERROR   \n 4 UNITED STATES 00000 EDU010190D   40737600 EDU0101      1990 ERROR   \n 5 UNITED STATES 00000 EDU010191D   41385442 EDU0101      1991 ERROR   \n 6 UNITED STATES 00000 EDU010192D   42088151 EDU0101      1992 ERROR   \n 7 UNITED STATES 00000 EDU010193D   42724710 EDU0101      1993 ERROR   \n 8 UNITED STATES 00000 EDU010194D   43369917 EDU0101      1994 ERROR   \n 9 UNITED STATES 00000 EDU010195D   43993459 EDU0101      1995 ERROR   \n10 UNITED STATES 00000 EDU010196D   44715737 EDU0101      1996 ERROR   \n# ℹ 1,050 more rows\n\n\n\nState Plot\nFor consistency sakes, we will re-list the code for our plot.state function here before applying it to the census_data object.\n\nplot.state &lt;- function(df, var_name = \"enrollment\"){\n  library(ggplot2)\n  \n# create subset data for plotting\nstate_variable_plot &lt;- df$state_data |&gt;\n\n# remove the error values\n    filter(division != \"ERROR\") |&gt;  \n\n# subset the data to the variables of interest\n    group_by(division, year) |&gt; \n  #create the mean statistic for plotting\n    summarize(\"mean_value\" = mean(get(var_name)))\n\n# generate the plot of year vs mean\n  g_state &lt;- ggplot(state_variable_plot, aes(year, mean_value, color=division)) \n\n# plot the division values\n  g_state + \n    geom_line() +\n    labs(title = paste(\"Average yearly\", var_name, \"by state division\")) +\n    xlab(\"Year\") +\n    ylab(paste(\"Average\", var_name))\n\n}\n\nUsing the plot.state function on census_data generates the plot of the state_data frame. This plot provides useful information that can be used to generate research questions to determine what cause such a contrast between the top 4 divisions from the bottom 5.\n\nplot.state(census_data)\n\n`summarise()` has grouped output by 'division'. You can override using the\n`.groups` argument.\n\n\n\n\n\n\n\n\n\n\n\nCounty plots\nLike with the plot.state function we will re-list the plot.county function code before applying it to the census_data object.\n\nplot.county &lt;- function(df, var_name = \"enrollment\", state_val = \"NC\", group = \"top\", row_display = 5) {\n  library(ggplot2)\n\n# extract the county df from the census_data object\n  county_variable_subset &lt;-  df$county_data |&gt;\n\n# filter the data to show only the state specified in the function string\n    filter(state == state_val) |&gt;\n    \n# find the overall mean of the statistic for each area name\n    group_by(area_name) |&gt; \n    summarize(\"mean_value\" = mean(get(var_name))) \n  \n# Sort the data to display the enrollment means from largest to smallest when \"top\" is chosen, or from smallets to largest when \"bottom\" is chosen. \n\nif(group == \"top\") {\n  sorted_data &lt;- county_variable_subset |&gt; arrange(desc(mean_value))\n} else if(group == \"bottom\") {\n  sorted_data &lt;- county_variable_subset |&gt; arrange(mean_value)\n} else {\n  stop(\"group must be in one of c('top', 'bottom')\")\n}\n  \n# obtain the top or bottom x number of area_names where the number is given by the user or default and filter the data to only include the top or bottom area names for graphing\n  \n  Display_num_subset &lt;- head(sorted_data, row_display)\n\n  # obtaining data corresponding to the top/bottom counties of interest\n  \n  counties_of_interest &lt;- df$county_data |&gt; semi_join(Display_num_subset, by = join_by(area_name))\n  \n  library(stringr)\n  \n  counties_of_interest |&gt; \n    ggplot(aes(x = year, y = get(var_name), color = area_name)) + \n    geom_line() +\n    xlab(\"Year\") +\n    ylab(str_to_title(str_replace(get(\"var_name\"), pattern = \"_\", replacement = \" \"))) +\n    labs(title = paste(str_to_title(paste(var_name, \"by county\")), \"in\", state_val), \n         subtitle = str_to_sentence(paste(group, row_display, \"counties\")))\n\n}\n\nUsing the plot.county function on county_data to generate plots using the below specified criteria provides useful information that can be used to generate research questions.\n\nSpecify state to be “NC”, group to be the “top”, and the number to be looked at being “20”.\n\n\nplot.county(census_data, state_val = \"NC\", var_name = \"enrollment\", group = \"top\", row_display = 20)\n\n\n\n\n\n\n\n\n\nSpecify state to be “SC”, group to be the “bottom”, and the number to be looked at being “7”.\n\n\nplot.county(census_data, state_val = \"SC\", var_name = \"enrollment\", group = \"bottom\", row_display = 7)\n\n\n\n\n\n\n\n\n\nUsing defaults\n\n\nplot.county(census_data)\n\n\n\n\n\n\n\n\n\nSpecifiy state to be “PA”, group to be the “top”, and the number to be looked at being “8”.\n\n\nplot.county(census_data, state_val = \"PA\", var_name = \"enrollment\", group = \"top\", row_display = 8)"
  },
  {
    "objectID": "st558_project1_group_r.html#read-in-similar-data-sets-and-apply-the-developed-functions.",
    "href": "st558_project1_group_r.html#read-in-similar-data-sets-and-apply-the-developed-functions.",
    "title": "ST 558 Project 1, Group R",
    "section": "Read in similar data sets and apply the developed functions.",
    "text": "Read in similar data sets and apply the developed functions.\nNow that we have tested and validated that our code works effectively on the data sets it was modeled to read, we will further test the code on another 4 raw data URLs generated by a separate census surveys.\n\nData processing\nProcessing the below URLs through the prepare_census_data function provides us with data frames PST01a through PST01d that we will combine into object PST01_combined with data frames state_data and county_data.\n\nhttps://www4.stat.ncsu.edu/~online/datasets/PST01a.csv\nhttps://www4.stat.ncsu.edu/~online/datasets/PST01b.csv\nhttps://www4.stat.ncsu.edu/~online/datasets/PST01c.csv\nhttps://www4.stat.ncsu.edu/~online/datasets/PST01d.csv\n\n\nPST01a &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/PST01a.csv\", \"population\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, PST015171N1, PST015171N2, PST015172N1, PST015172...\ndbl (20): PST015171F, PST015171D, PST015172F, PST015172D, PST015173F, PST015...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nPST01b &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/PST01b.csv\", \"population\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, PST025182N1, PST025182N2, PST025183N1, PST025183...\ndbl (20): PST025182F, PST025182D, PST025183F, PST025183D, PST025184F, PST025...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nPST01c &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/PST01c.csv\", \"population\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, PST035191N1, PST035191N2, PST035192N1, PST035192...\ndbl (20): PST035191F, PST035191D, PST035192F, PST035192D, PST035193F, PST035...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nPST01d &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/PST01d.csv\", \"population\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, PST045200N1, PST045200N2, PST045201N1, PST045201...\ndbl (20): PST045200F, PST045200D, PST045201F, PST045201D, PST045202F, PST045...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "st558_project1_group_r.html#data-combining-1",
    "href": "st558_project1_group_r.html#data-combining-1",
    "title": "ST 558 Project 1, Group R",
    "section": "Data combining",
    "text": "Data combining\nProcessing our newly generated data frames through our data will generate our PST01_combined data objet that will be used for subsetting before analysis. Because our function in only designed to combine two data frames at a time, we will combine PST01a with PST01b, PST01c with PST01d, then combining the resulting data frames PST01ab and PST01cd to create our desired object PST01_combined.\n\nPST01ab &lt;- combine_data(PST01a, PST01b)\n\nPST01cd &lt;- combine_data(PST01c, PST01d)\n\nPST01_combined &lt;- combine_data(PST01ab, PST01cd)"
  },
  {
    "objectID": "st558_project1_group_r.html#state-data-frame-plot",
    "href": "st558_project1_group_r.html#state-data-frame-plot",
    "title": "ST 558 Project 1, Group R",
    "section": "State data frame plot",
    "text": "State data frame plot\nNow that we have our data object, will use the function plot.state to generate the plot of PST01_combined’s state data frame in order to compare the mean populations of the different divisions.\n\nplot.state(PST01_combined, \"population\")\n\n`summarise()` has grouped output by 'division'. You can override using the\n`.groups` argument."
  },
  {
    "objectID": "st558_project1_group_r.html#county-data-frame-plots",
    "href": "st558_project1_group_r.html#county-data-frame-plots",
    "title": "ST 558 Project 1, Group R",
    "section": "County data frame plots",
    "text": "County data frame plots\nNext, we will use the plot.county function to generate the plot of PST01_combined’s county data frame using the below specified criteria.\n\nSpecify the state to be “CA”, the group to be the “top”, and the number looked at being “15”.\n\n\nplot.county(PST01_combined, state_val = \"CA\", var_name = \"population\", group = \"top\", row_display = 15)\n\n\n\n\n\n\n\n\n\nSpecify the state to be “TX”, the group to be the “top”, and the number looked at being “4”.\n\n\nplot.county(PST01_combined, state_val = \"TX\", var_name = \"population\", group = \"top\", row_display = 4)\n\n\n\n\n\n\n\n\n\nUsing defaults only.\n\nUsing the default value of “enrollment” for the variable “population” renders an error message. Because of this, we have listed the default value to be “population” to show that the code is working properly otherwise.\n\nplot.county(PST01_combined, \"population\")\n\n\n\n\n\n\n\n\n\nSpecifying the state to be “NY”, the group being the “top”, and the number looked at being “10”.\n\n\nplot.county(PST01_combined, state_val = \"NY\", var_name = \"population\", group = \"top\", row_display = 10)"
  }
]