[
  {
    "objectID": "st558_project1_group_r.html",
    "href": "st558_project1_group_r.html",
    "title": "ST 558 Project 1, Group R",
    "section": "",
    "text": "For this project, we’ll want to read in and prepare the data for analysis. Then we’ll actually conduct the analysis. But we’ll want to create functions for each step to make the code easy to maintain and debug and reuse as necessary.\nFirst, we’ll read in and prep the data manually. Afterward, we’ll put those manual steps into a function.\n\nlibrary(readr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\n\n# step 1 and 2 and 3\ncensus_data &lt;- read_csv(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\") |&gt; \n  select(Area_name, STCOU, ends_with(\"D\")) |&gt; # step 1\n  rename(area_name = Area_name) |&gt; \n  pivot_longer(ends_with(\"D\")) |&gt; # step 2\n  mutate(\n    measurement = substr(name, 1, 7),\n    year = paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer()) # step 3\n\nRows: 3198 Columns: 42\n\n\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010187N1, EDU010187N2, EDU010188N1, EDU010188...\ndbl (20): EDU010187F, EDU010187D, EDU010188F, EDU010188D, EDU010189F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# step 4\n# Grabbing state indices so we can split the data between county/non-county data\ncounty_idx &lt;-  grep(pattern = \", \\\\w\\\\w\", census_data$area_name)\n\n# county-level data\n# using indices for county level, and omitting indices for non-county level data\ncensus_county_lvl &lt;- census_data[county_idx, ]\ncensus_non_county_lvl &lt;- census_data[-county_idx, ]\n\n# New classes for new methods later\nclass(census_county_lvl) &lt;- c(\"county\", class(census_county_lvl))\nclass(census_non_county_lvl) &lt;- c(\"state\", class(census_non_county_lvl))\n\n# step 5\n# appending 2-char state abbreviation for county level data\n# stringr package allows us to index in reverse, no user defined function needed\ncensus_county_lvl &lt;- census_county_lvl |&gt; \n  mutate(state = stringr::str_sub(area_name, -2))\n\n# step 6\n# area_name has two versions of DC, which is in division 5. We'll standardize this. We assume these aren't true duplicates since STCOUs are different for upper, lowercase versions of DC.\n# We'll also use built-in R variables to make a reference table for the regions.\n# This will make appending division to our non-county level data simpler.\n\n# Making reference table\n# Upper casing state names for table join later\nstates_upper_case &lt;- c(toupper(state.name), \"DISTRICT OF COLUMBIA\")\nstates_division &lt;- c(state.division, factor(\"South Atlantic\"))\n\nstate_ref_table &lt;- data.frame(state = states_upper_case, division = states_division)\n\n# We'll join our state reference table to our census data to append divisions.\n# We do this by standardizing DC as upper case for the keys. Then, since factors can be a bit tricky, we convert to character type first. Lastly, any NAs are changed to ERROR as these don't correspond to any divisions, just \"UNITED STATES\"\n\ncensus_non_county_lvl &lt;- census_non_county_lvl |&gt; \n  mutate(area_name = toupper(area_name)) |&gt; \n  left_join(state_ref_table, by = join_by(area_name == state)) |&gt;\n  mutate(division = as.character(division),\n         division = if_else(is.na(division), \"ERROR\", division))"
  },
  {
    "objectID": "st558_project1_group_r.html#manual-read-in",
    "href": "st558_project1_group_r.html#manual-read-in",
    "title": "ST 558 Project 1, Group R",
    "section": "",
    "text": "For this project, we’ll want to read in and prepare the data for analysis. Then we’ll actually conduct the analysis. But we’ll want to create functions for each step to make the code easy to maintain and debug and reuse as necessary.\nFirst, we’ll read in and prep the data manually. Afterward, we’ll put those manual steps into a function.\n\nlibrary(readr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\n\n# step 1 and 2 and 3\ncensus_data &lt;- read_csv(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\") |&gt; \n  select(Area_name, STCOU, ends_with(\"D\")) |&gt; # step 1\n  rename(area_name = Area_name) |&gt; \n  pivot_longer(ends_with(\"D\")) |&gt; # step 2\n  mutate(\n    measurement = substr(name, 1, 7),\n    year = paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer()) # step 3\n\nRows: 3198 Columns: 42\n\n\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010187N1, EDU010187N2, EDU010188N1, EDU010188...\ndbl (20): EDU010187F, EDU010187D, EDU010188F, EDU010188D, EDU010189F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# step 4\n# Grabbing state indices so we can split the data between county/non-county data\ncounty_idx &lt;-  grep(pattern = \", \\\\w\\\\w\", census_data$area_name)\n\n# county-level data\n# using indices for county level, and omitting indices for non-county level data\ncensus_county_lvl &lt;- census_data[county_idx, ]\ncensus_non_county_lvl &lt;- census_data[-county_idx, ]\n\n# New classes for new methods later\nclass(census_county_lvl) &lt;- c(\"county\", class(census_county_lvl))\nclass(census_non_county_lvl) &lt;- c(\"state\", class(census_non_county_lvl))\n\n# step 5\n# appending 2-char state abbreviation for county level data\n# stringr package allows us to index in reverse, no user defined function needed\ncensus_county_lvl &lt;- census_county_lvl |&gt; \n  mutate(state = stringr::str_sub(area_name, -2))\n\n# step 6\n# area_name has two versions of DC, which is in division 5. We'll standardize this. We assume these aren't true duplicates since STCOUs are different for upper, lowercase versions of DC.\n# We'll also use built-in R variables to make a reference table for the regions.\n# This will make appending division to our non-county level data simpler.\n\n# Making reference table\n# Upper casing state names for table join later\nstates_upper_case &lt;- c(toupper(state.name), \"DISTRICT OF COLUMBIA\")\nstates_division &lt;- c(state.division, factor(\"South Atlantic\"))\n\nstate_ref_table &lt;- data.frame(state = states_upper_case, division = states_division)\n\n# We'll join our state reference table to our census data to append divisions.\n# We do this by standardizing DC as upper case for the keys. Then, since factors can be a bit tricky, we convert to character type first. Lastly, any NAs are changed to ERROR as these don't correspond to any divisions, just \"UNITED STATES\"\n\ncensus_non_county_lvl &lt;- census_non_county_lvl |&gt; \n  mutate(area_name = toupper(area_name)) |&gt; \n  left_join(state_ref_table, by = join_by(area_name == state)) |&gt;\n  mutate(division = as.character(division),\n         division = if_else(is.na(division), \"ERROR\", division))"
  },
  {
    "objectID": "st558_project1_group_r.html#creating-data-preprocessing-functions",
    "href": "st558_project1_group_r.html#creating-data-preprocessing-functions",
    "title": "ST 558 Project 1, Group R",
    "section": "Creating data preprocessing functions",
    "text": "Creating data preprocessing functions\nWe’ll create some functions to perform the following steps:\n\nRead in the census data and select Area_name, STCOU, and any column ending in “D”. We’ll also rename Area_name to area_name.\nConvert the data into long format, keeping Area_name as the reference for our enrollment values.\nA name column will create by default that contains the old column names. From these old column names, we’ll extract the survey type and the year.\nCreate two data sets, one for county-level data and one for non-county data. We’ll also add a state and county class to the relevant subsets of data.\nFor the county level data, we’ll create a variable that corresponds to the state a county belongs to.\nFor non-county level data, we’ll create a variable that corresponds to the [state’s classification of division].(https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States)\n\n\nSteps 1-2\nWe’ll start with a function for steps 1-2. We’ll provide an optional argument that allows us to provide a name for the default value column that is created by pivot_longer.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# step 1 and 2\n\nurl &lt;- \"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\"\ndefault_var_name &lt;- \"value\"\n\nread_and_pivot &lt;- function(url, default_var_name = \"value\") {\n  \n  census_data &lt;- read_csv(url) |&gt; \n    select(Area_name, STCOU, ends_with(\"D\")) |&gt; # step 1\n    rename(area_name = Area_name) |&gt; \n    pivot_longer(ends_with(\"D\"), values_to = default_var_name) # step 2\n  \n  census_data\n}\n\n\n\nStep 3\nFrom the default name column created by pivot_longer that captures the variable names ending in “D”, we’ll extract the survey type and year, which will be reflected by the measurement and year columns created, respectively.\nWe have to be careful, however. The exploration isn’t done here, but EDU01a.csv data captures the years 1987 - 1996, where the EDU01b.csv data captures the years 1997-2006. So we need to account for the millennium we’re in.\n\nextract_survey_and_year &lt;- function(df) {\n  \n  res &lt;- df |&gt;\n  mutate(\n      measurement = substr(name, 1, 7),\n      # year = paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer())\n      year = ifelse(\n        substr(name, 8, 8) %in% c(\"8\", \"9\"), paste0(\"19\", substr(name, 8, 9)) |&gt; as.integer(),\n        ifelse(\n          substr(name, 8, 8) %in% c(\"0\", \"1\"), paste0(\"20\", substr(name, 8, 9)) |&gt; as.integer(),\n          NA)\n        )\n  )\n  \n  res\n}\n\n\n\nStep 5\nThe data from step 3 above will result in a data frame with county-level and non-county level data, each of which will require different prep methods. Here, we’ll create a function to extract the county-level state from area_name.\n\nlibrary(stringr)\n\n# stringr's str_sub allows us to substring in reverse, easier than base R's substr\nextract_state_from_area &lt;- function(census_county_lvl) {\n  res &lt;- census_county_lvl |&gt; \n    mutate(state = stringr::str_sub(area_name, -2)) # grab last two characters\n  \n  res\n}\n\n\n\nStep 6\nFor non-county level data, we’ll create a function that assigns a variable that corresponds to the [state’s classification of division].(https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States)\nThe approach we take will make use of some built-in state data in R.\n\n# step 6\n# area_name has two versions of DC, uppercase and lowercase, which is in division 5. We'll standardize this. \n# We assume these aren't true duplicates since STCOUs are different for upper, lowercase versions of DC.\n# We'll also use built-in R variables to make a reference table for the regions.\n# This will make appending division to our non-county level data simpler.\n\nassign_state_divisions &lt;- function(census_non_county_lvl) {\n  # Making reference table\n  # Upper casing state names for table join later\n  states_upper_case &lt;- c(toupper(state.name), \"DISTRICT OF COLUMBIA\") # DC doesn't exist in this vector, so we add it\n  states_division &lt;- c(state.division, factor(\"South Atlantic\")) # Adding DC's division level to factor vector of divisions\n  \n  state_ref_table &lt;- data.frame(state = states_upper_case, division = states_division)\n  \n  # We'll join our state reference table to our census data to append divisions.\n  # We do this by standardizing DC as upper case for the keys. Then, since factors can be a bit tricky, we convert to character type first. Lastly, any NAs are changed to ERROR as these don't correspond to any state divisions\n  \n  res &lt;- census_non_county_lvl |&gt; \n    mutate(area_name = toupper(area_name)) |&gt; \n    left_join(state_ref_table, by = join_by(area_name == state)) |&gt;\n    mutate(division = as.character(division),\n           division = if_else(is.na(division), \"ERROR\", division))\n  \n  res\n}\n\n\n\nPutting steps 4, 5, and 6 together\nWe mentioned that the data has county-level and non-county-level data that needs to be addressed separately. Functions for steps 5 and 6 do this. We now address step 4, which is splitting the data into county and non-county level data. We’ll combine this right into steps 5 and 6 below.\n\nsplit_census_data &lt;- function(census_data) {\n  \n  # step 4\n  \n  # Grabbing state indices so we can split the data between county/non-county data\n  # This is because county-level data follows the pattern \"County, DD\"\n  # DD is the state abbreviation.\n  county_idx &lt;-  grep(pattern = \", \\\\w\\\\w\", census_data$area_name)\n  \n  # using indices for county level, and omitting indices for non-county level data\n  census_county_lvl &lt;- census_data[county_idx, ]\n  census_non_county_lvl &lt;- census_data[-county_idx, ]\n  \n  # New classes for new methods later\n  class(census_county_lvl) &lt;- c(\"county\", class(census_county_lvl))\n  class(census_non_county_lvl) &lt;- c(\"state\", class(census_non_county_lvl))\n  \n  # step 5\n  \n  # applying step 5 for county level data\n  county_res &lt;- extract_state_from_area(census_county_lvl)\n  \n  # step 6\n  \n  # applying step 6 for non-county level data\n  state_res &lt;- assign_state_divisions(census_non_county_lvl)\n  \n  full_res &lt;- list(county_data = county_res, state_data = state_res)\n  \n  full_res\n}\n\n\n\nCombining steps 1-6 in a wrapper function\nWe’ll now create a wrapper function that combines the functions created above into one call. It’ll take as input the data’s url, and an optional argument for the value column name created by pivot_longer.\n\nprepare_census_data &lt;- function(url, default_var_name = \"value\") {\n  \n  res &lt;- read_and_pivot(url, default_var_name) |&gt; # step 1, 2 \n    extract_survey_and_year() |&gt; # step 3\n    split_census_data() # step 4, 5, 6\n  \n  res\n}\n\n\n\nUsing wrapper function for Census data\nWe’ll be calling our wrapper function above on the following two datasets:\n\nhttps://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\nhttps://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv\n\nThen we’ll be combining the county- and state-level results from each appropriately.\n\n# Reading in and prepping the two EDU01 census .csv files given\n\ncensus_edu01a &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv\", \"enrollment\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010187N1, EDU010187N2, EDU010188N1, EDU010188...\ndbl (20): EDU010187F, EDU010187D, EDU010188F, EDU010188D, EDU010189F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ncensus_edu01b &lt;- prepare_census_data(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv\", \"enrollment\")\n\nRows: 3198 Columns: 42\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (22): Area_name, STCOU, EDU010197N1, EDU010197N2, EDU010198N1, EDU010198...\ndbl (20): EDU010197F, EDU010197D, EDU010198F, EDU010198D, EDU010199F, EDU010...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# helper function to combine the two sets of data\ncombine_data &lt;- function(list_of_dfs1, list_of_dfs2) {\n  \n  # county\n  county_res &lt;- bind_rows(list_of_dfs1$county_data, list_of_dfs2$county_data)\n  \n  # state\n  state_res &lt;- bind_rows(list_of_dfs1$state_data, list_of_dfs2$state_data)\n  \n  res &lt;- list(county_data = county_res, state_data = state_res)\n  \n  res\n}\n\nWe now call our combine_data function to save the results of the prepared EDU01a and EDU01b data sets into a two-element list of dataframes, where each element of the list corresponds to combined county-level and state-level data.\n\ncensus_data &lt;- combine_data(census_edu01a, census_edu01b)\n\ncensus_data\n\n$county_data\n# A tibble: 62,900 × 7\n   area_name   STCOU name       enrollment measurement  year state\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;\n 1 Autauga, AL 01001 EDU010187D       6829 EDU0101      1987 AL   \n 2 Autauga, AL 01001 EDU010188D       6900 EDU0101      1988 AL   \n 3 Autauga, AL 01001 EDU010189D       6920 EDU0101      1989 AL   \n 4 Autauga, AL 01001 EDU010190D       6847 EDU0101      1990 AL   \n 5 Autauga, AL 01001 EDU010191D       7008 EDU0101      1991 AL   \n 6 Autauga, AL 01001 EDU010192D       7137 EDU0101      1992 AL   \n 7 Autauga, AL 01001 EDU010193D       7152 EDU0101      1993 AL   \n 8 Autauga, AL 01001 EDU010194D       7381 EDU0101      1994 AL   \n 9 Autauga, AL 01001 EDU010195D       7568 EDU0101      1995 AL   \n10 Autauga, AL 01001 EDU010196D       7834 EDU0101      1996 AL   \n# ℹ 62,890 more rows\n\n$state_data\n# A tibble: 1,060 × 7\n   area_name     STCOU name       enrollment measurement  year division\n   &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;   \n 1 UNITED STATES 00000 EDU010187D   40024299 EDU0101      1987 ERROR   \n 2 UNITED STATES 00000 EDU010188D   39967624 EDU0101      1988 ERROR   \n 3 UNITED STATES 00000 EDU010189D   40317775 EDU0101      1989 ERROR   \n 4 UNITED STATES 00000 EDU010190D   40737600 EDU0101      1990 ERROR   \n 5 UNITED STATES 00000 EDU010191D   41385442 EDU0101      1991 ERROR   \n 6 UNITED STATES 00000 EDU010192D   42088151 EDU0101      1992 ERROR   \n 7 UNITED STATES 00000 EDU010193D   42724710 EDU0101      1993 ERROR   \n 8 UNITED STATES 00000 EDU010194D   43369917 EDU0101      1994 ERROR   \n 9 UNITED STATES 00000 EDU010195D   43993459 EDU0101      1995 ERROR   \n10 UNITED STATES 00000 EDU010196D   44715737 EDU0101      1996 ERROR   \n# ℹ 1,050 more rows\n\n\nWe are now ready to analyze this data."
  },
  {
    "objectID": "st558_project1_group_r.html#to-do",
    "href": "st558_project1_group_r.html#to-do",
    "title": "ST 558 Project 1, Group R",
    "section": "TO DO",
    "text": "TO DO\nRead pages 4-5 of the Project 1 .pdf file and follow the instructions therein. DO NOT RENDER ANYTHING YET, just focus on getting the code to run as instructed. I’m happy to help walk/talk you through anything that is difficult, don’t hesitate to ask. We can set some time up to work on it live.\nFor every milestone (project step), commit (but don’t push yet) any changes. Once we make sure all steps work as planned, we can then do a file commit/push to Github. I’m not a Github expert so I think this approach will save us headaches trying to debug any Github issues.\n\n# Begin coding"
  },
  {
    "objectID": "project1.html",
    "href": "project1.html",
    "title": "Project 1",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(readr)"
  },
  {
    "objectID": "project1.html#first-steps.-read-in-one-section-of-the-data-found-at-httpswww4.stat.ncsu.eduonlinedatasetsedu01b.csv.",
    "href": "project1.html#first-steps.-read-in-one-section-of-the-data-found-at-httpswww4.stat.ncsu.eduonlinedatasetsedu01b.csv.",
    "title": "Project 1",
    "section": "First Steps. Read in one section of the data found at “https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv”.",
    "text": "First Steps. Read in one section of the data found at “https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv”.\n\n1. Only select the columns:\n\nArea_name STC0U Any column that ends in “D”\n\n\nEDU01a &lt;- read_csv(\"https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv\",\nshow_col_types = FALSE)\n\nEDU01a &lt;- EDU01a |&gt;\n  select(\"area_name\" = Area_name, STCOU, ends_with((\"D\")) )\n\nEDU01a\n\n# A tibble: 3,198 × 12\n   area_name     STCOU EDU010197D EDU010198D EDU010199D EDU010200D EDU010201D\n   &lt;chr&gt;         &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 UNITED STATES 00000   44534459   46245814   46368903   46818690   47127066\n 2 ALABAMA       01000     737386     739321     737639     731613     730627\n 3 Autauga, AL   01001       8099       8211       8489       8912       8626\n 4 Baldwin, AL   01003      21410      21771      22176      22337      22656\n 5 Barbour, AL   01005       5100       5024       4906       4793       4671\n 6 Bibb, AL      01007       3717       3760       3689       3646       3556\n 7 Blount, AL    01009       7816       8054       8135       8346       8517\n 8 Bullock, AL   01011       2010       1989       1945       1953       1981\n 9 Butler, AL    01013       4119       3989       3850       3665       3632\n10 Calhoun, AL   01015      19721      19565      19267      18291      18175\n# ℹ 3,188 more rows\n# ℹ 5 more variables: EDU010202D &lt;dbl&gt;, EDU015203D &lt;dbl&gt;, EDU015204D &lt;dbl&gt;,\n#   EDU015205D &lt;dbl&gt;, EDU015206D &lt;dbl&gt;\n\n\n\n\n2. Convert the data into long format where each row has only one value for that area_name\n\nEDU01a |&gt;\n  pivot_longer(\n    cols = 3:12,\n    names_to =  \"EDU_Code\",\n    values_to = \"Area_EDU_Total\"\n               )\n\n# A tibble: 31,980 × 4\n   area_name     STCOU EDU_Code   Area_EDU_Total\n   &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt;\n 1 UNITED STATES 00000 EDU010197D       44534459\n 2 UNITED STATES 00000 EDU010198D       46245814\n 3 UNITED STATES 00000 EDU010199D       46368903\n 4 UNITED STATES 00000 EDU010200D       46818690\n 5 UNITED STATES 00000 EDU010201D       47127066\n 6 UNITED STATES 00000 EDU010202D       47606570\n 7 UNITED STATES 00000 EDU015203D       48506317\n 8 UNITED STATES 00000 EDU015204D       48693287\n 9 UNITED STATES 00000 EDU015205D       48978555\n10 UNITED STATES 00000 EDU015206D       49140702\n# ℹ 31,970 more rows"
  },
  {
    "objectID": "project1.html#requiremnets.-repeat-steps-1-through-6-above-for-the-2nd-component-of-the-data-set-which-can-be-found-at-httpswww4.stat.ncsu.eduonlinedatasetsedu01b.csv",
    "href": "project1.html#requiremnets.-repeat-steps-1-through-6-above-for-the-2nd-component-of-the-data-set-which-can-be-found-at-httpswww4.stat.ncsu.eduonlinedatasetsedu01b.csv",
    "title": "Project 1",
    "section": "Requiremnets. Repeat Steps 1 through 6 above for the 2nd component of the data set, which can be found at “https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv”",
    "text": "Requiremnets. Repeat Steps 1 through 6 above for the 2nd component of the data set, which can be found at “https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv”"
  }
]